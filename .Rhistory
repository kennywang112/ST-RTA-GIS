type = 4
extra = 106,
#| message: false
#| warning: false
tree_bad_model <- rpart(Group_Label ~ . ,
data = bad_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = bad_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(bad_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_bad_model.png", width = 1200, height = 900)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
shadow.col = "gray",  # 陰影
nn = TRUE,            # 顯示節點編號 (方便討論)
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
tree_res_model <- rpart(Group_Label ~ . ,
data = res_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_res_model, newdata = res_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(res_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_res_model.png", width = 1200, height = 900, res = 300)
rpart.plot(tree_res_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
tree_res_model <- rpart(Group_Label ~ . ,
data = res_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_res_model, newdata = res_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(res_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_res_model.png", width = 1200, height = 900, res = 300)
rpart.plot(tree_res_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
#| message: false
#| warning: false
tree_bad_model <- rpart(Group_Label ~ . ,
data = bad_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = bad_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(bad_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_bad_model.png", width = 1200, height = 800)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
us_data_for_tree <- final_data_for_tree%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
bad_group_balanced <- do_undersampling(
us_data_for_tree,
"Hot_with_Safe_Neighbors_highbetweenness",
"Broken_Neighbors"
)
res_group_balanced <- do_undersampling(
us_data_for_tree,
"Cold_with_Hot_Neighbors_highbetweenness",
"Resilient_Neighbors"
)
#| message: false
#| warning: false
tree_bad_model <- rpart(Group_Label ~ . ,
data = bad_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = bad_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(bad_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_bad_model.png", width = 1200, height = 800)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
hotspot_threshold <- 0.5
df <- features %>% mutate(is_hotspot = hotspot > hotspot_threshold)
df <- df %>%
# check if there's hot or safe neighbor first
mutate(
neighbor_hotspot_ratio = map_dbl(neighbors, function(idx) {
if(length(idx) == 0) return(0)
mean(df$is_hotspot[idx])}),
has_safe_neighbor = neighbor_hotspot_ratio < 1,
has_hot_neighbor = neighbor_hotspot_ratio > 0)%>%
# check if itself is hot or safe & the neighbor_hotspot_ratio
# set high betweenness threshold
mutate(
node_category = case_when(
is_hotspot == TRUE & has_safe_neighbor == TRUE ~ "Hot_with_Safe_Neighbors",
is_hotspot == FALSE & has_hot_neighbor == TRUE ~ "Cold_with_Hot_Neighbors",
TRUE ~ "Others"
),
is_high_betweenness = betweenness >= quantile(df$betweenness, 0.9)
)%>%
# finally find the interesting point
mutate(
final_category = case_when(
is_hotspot == TRUE & has_safe_neighbor == TRUE & is_high_betweenness == TRUE ~ "Hot_with_Safe_Neighbors_highbetweenness",
is_hotspot == FALSE & has_hot_neighbor == TRUE & is_high_betweenness == TRUE ~ "Cold_with_Hot_Neighbors_highbetweenness",
TRUE ~ "Others"
)
)
table(df$final_category)
source('../utils/model.R')
final_all_features <- cbind(all_features)#, result$max_spd_dlt)
result_data <- get_comparison_data(df, final_all_features)
result_data%>%
group_by(group_label)%>%
summarize(n())
source('../utils/model.R')
final_all_features <- cbind(all_features)#, result$max_spd_dlt)
result_data <- get_comparison_data(df, final_all_features)
result_data%>%
group_by(group_label)%>%
summarize(n())
analysis_data <- result_data%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
cols_to_remove <- c(
# "車道劃分設施-分道設施-路面邊線名稱_有"
"Road Edge Line_Present"
)
analysis_data <- result_data%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
analysis_data
analysis_data%>%
group_by(group_label)%>%
summarise(n())
#| message: false
#| warning: false
library(rpart)
library(rpart.plot)
cols_to_remove <- c(
# "車道劃分設施-分道設施-路面邊線名稱_有"
"Road Edge Line_Present"
)
analysis_data <- result_data%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
tree_model <- rpart(group_label ~ . , data = analysis_data, method = "class")
library(showtext)
showtext_auto()
png("../Layouts/tree_model.png", width = 1200, height = 600)
rpart.plot(tree_model, family = "PingFang", tweak = 1.2)
dev.off()
# 找鄰居的時候有個限制：鄰居一定要和自己是相反的，熱點抓鄰居也是熱點的沒有意義
get_four_categories_data <- function(labeled_features, all_features_grid) {
process_group <- function(
self_category_name, neighbor_category_name, neighbor_must_be_hot
) {
self_nodes <- labeled_features %>% filter(final_category == self_category_name)
self_node_indices <- which(labeled_features$final_category == self_category_name)
valid_neighbor_node_indices <- unique(unlist(lapply(self_nodes$neighbors, function(nbs) {
nbs_status <- labeled_features$is_hotspot[nbs]
# If neighbor_must_be_hot is TRUE，only save TRUE
# If neighbor_must_be_hot is FALSE，only save FALSE
real_nbs <- nbs[nbs_status == neighbor_must_be_hot]
# Remove self again to make sure
final_nbs <- setdiff(real_nbs, self_node_indices)
return(final_nbs)
})))
grid_indices_self <- unique(unlist(labeled_features$points_in_vertex[self_node_indices]))
grid_indices_neighbor <- unique(unlist(labeled_features$points_in_vertex[valid_neighbor_node_indices]))
ambiguous_grids <- intersect(grid_indices_self, grid_indices_neighbor)
clean_self_grids <- setdiff(grid_indices_self, ambiguous_grids)
clean_neighbor_grids <- setdiff(grid_indices_neighbor, ambiguous_grids)
df_self <- all_features_grid[clean_self_grids, ] %>%
mutate(Group_Label = self_category_name)
df_neighbor <- all_features_grid[clean_neighbor_grids, ] %>%
mutate(Group_Label = neighbor_category_name)
return(bind_rows(df_self, df_neighbor))
}
data_group_a <- process_group(
self_category_name = "Broken", # Hot_with_Safe_Neighbors_highbetweenness
neighbor_category_name = "Broken_Neighbors",
neighbor_must_be_hot = FALSE
)
data_group_b <- process_group(
self_category_name = "Resilient", # Cold_with_Hot_Neighbors_highbetweenness
neighbor_category_name = "Resilient_Neighbors",
neighbor_must_be_hot = TRUE
)
final_dataset <- bind_rows(data_group_a, data_group_b)
return(final_dataset)
}
final_data_for_tree <- get_four_categories_data(df, final_all_features)
MapperPlotter(
Mapper,
label = df$final_category,
original_data = filter_data,
use_embedding=TRUE
)
do_undersampling <- function(
df, group1_name, group2_name
) {
data_g1 <- df %>% filter(Group_Label == group1_name)
data_g2 <- df %>% filter(Group_Label == group2_name)
n_g1 <- nrow(data_g1)
n_g2 <- nrow(data_g2)
cat(sprintf("原始數量 -> %s: %d, %s: %d\n", group1_name, n_g1, group2_name, n_g2))
target_n <- min(n_g1, n_g2)
set.seed(123)
data_g1_balanced <- data_g1 %>% sample_n(target_n)
data_g2_balanced <- data_g2 %>% sample_n(target_n)
balanced_df <- bind_rows(data_g1_balanced, data_g2_balanced)
cat(sprintf("平衡後數量 -> 各 %d 筆 (總共 %d 筆)\n", target_n, nrow(balanced_df)))
return(balanced_df)
}
#| message: false
#| warning: false
tree_bad_model <- rpart(Group_Label ~ . ,
data = bad_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = bad_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(bad_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_bad_model.png", width = 1200, height = 800)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
us_data_for_tree <- final_data_for_tree%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
bad_group_balanced <- do_undersampling(
us_data_for_tree,
"Hot_with_Safe_Neighbors_highbetweenness",
"Broken_Neighbors"
)
res_group_balanced <- do_undersampling(
us_data_for_tree,
"Cold_with_Hot_Neighbors_highbetweenness",
"Resilient_Neighbors"
)
us_data_for_tree
us_data_for_tree
us_data_for_tree <- final_data_for_tree%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
us_data_for_tree
# 找鄰居的時候有個限制：鄰居一定要和自己是相反的，熱點抓鄰居也是熱點的沒有意義
get_four_categories_data <- function(labeled_features, all_features_grid) {
process_group <- function(
self_category_name, neighbor_category_name, neighbor_must_be_hot
) {
self_nodes <- labeled_features %>% filter(final_category == self_category_name)
self_node_indices <- which(labeled_features$final_category == self_category_name)
valid_neighbor_node_indices <- unique(unlist(lapply(self_nodes$neighbors, function(nbs) {
nbs_status <- labeled_features$is_hotspot[nbs]
# If neighbor_must_be_hot is TRUE，only save TRUE
# If neighbor_must_be_hot is FALSE，only save FALSE
real_nbs <- nbs[nbs_status == neighbor_must_be_hot]
# Remove self again to make sure
final_nbs <- setdiff(real_nbs, self_node_indices)
return(final_nbs)
})))
grid_indices_self <- unique(unlist(labeled_features$points_in_vertex[self_node_indices]))
grid_indices_neighbor <- unique(unlist(labeled_features$points_in_vertex[valid_neighbor_node_indices]))
ambiguous_grids <- intersect(grid_indices_self, grid_indices_neighbor)
clean_self_grids <- setdiff(grid_indices_self, ambiguous_grids)
clean_neighbor_grids <- setdiff(grid_indices_neighbor, ambiguous_grids)
df_self <- all_features_grid[clean_self_grids, ] %>%
mutate(Group_Label = self_category_name)
df_neighbor <- all_features_grid[clean_neighbor_grids, ] %>%
mutate(Group_Label = neighbor_category_name)
return(bind_rows(df_self, df_neighbor))
}
data_group_a <- process_group(
self_category_name = "Broken", # Hot_with_Safe_Neighbors_highbetweenness
neighbor_category_name = "Broken_Neighbors",
neighbor_must_be_hot = FALSE
)
data_group_b <- process_group(
self_category_name = "Resilient", # Cold_with_Hot_Neighbors_highbetweenness
neighbor_category_name = "Resilient_Neighbors",
neighbor_must_be_hot = TRUE
)
final_dataset <- bind_rows(data_group_a, data_group_b)
return(final_dataset)
}
final_data_for_tree <- get_four_categories_data(df, final_all_features)
final_data_for_tree
# 找鄰居的時候有個限制：鄰居一定要和自己是相反的，熱點抓鄰居也是熱點的沒有意義
get_four_categories_data <- function(labeled_features, all_features_grid) {
process_group <- function(
self_category_name, neighbor_category_name, neighbor_must_be_hot
) {
self_nodes <- labeled_features %>% filter(final_category == self_category_name)
self_node_indices <- which(labeled_features$final_category == self_category_name)
valid_neighbor_node_indices <- unique(unlist(lapply(self_nodes$neighbors, function(nbs) {
nbs_status <- labeled_features$is_hotspot[nbs]
# If neighbor_must_be_hot is TRUE，only save TRUE
# If neighbor_must_be_hot is FALSE，only save FALSE
real_nbs <- nbs[nbs_status == neighbor_must_be_hot]
# Remove self again to make sure
final_nbs <- setdiff(real_nbs, self_node_indices)
return(final_nbs)
})))
grid_indices_self <- unique(unlist(labeled_features$points_in_vertex[self_node_indices]))
grid_indices_neighbor <- unique(unlist(labeled_features$points_in_vertex[valid_neighbor_node_indices]))
ambiguous_grids <- intersect(grid_indices_self, grid_indices_neighbor)
clean_self_grids <- setdiff(grid_indices_self, ambiguous_grids)
clean_neighbor_grids <- setdiff(grid_indices_neighbor, ambiguous_grids)
df_self <- all_features_grid[clean_self_grids, ] %>%
mutate(Group_Label = self_category_name)
df_neighbor <- all_features_grid[clean_neighbor_grids, ] %>%
mutate(Group_Label = neighbor_category_name)
return(bind_rows(df_self, df_neighbor))
}
data_group_a <- process_group(
self_category_name = "Hot_with_Safe_Neighbors_highbetweenness",
neighbor_category_name = "Broken_Neighbors",
neighbor_must_be_hot = FALSE
)
data_group_b <- process_group(
self_category_name = "Cold_with_Hot_Neighbors_highbetweenness",
neighbor_category_name = "Resilient_Neighbors",
neighbor_must_be_hot = TRUE
)
final_dataset <- bind_rows(data_group_a, data_group_b)
return(final_dataset)
}
final_data_for_tree <- get_four_categories_data(df, final_all_features)
# rename rowname
final_data_for_tree
# rename rowname
final_data_for_tree%>%colnames()
final_data_for_tree <- final_data_for_tree %>%
mutate(Group_Label = recode(Group_Label,
"Hot_with_Safe_Neighbors_highbetweenness" = "Broken",
"Cold_with_Hot_Neighbors_highbetweenness" = "Resilient"
))
MapperPlotter(
Mapper,
label = df$final_category,
original_data = filter_data,
use_embedding=TRUE
)
final_data_for_tree
do_undersampling <- function(
df, group1_name, group2_name
) {
data_g1 <- df %>% filter(Group_Label == group1_name)
data_g2 <- df %>% filter(Group_Label == group2_name)
n_g1 <- nrow(data_g1)
n_g2 <- nrow(data_g2)
cat(sprintf("原始數量 -> %s: %d, %s: %d\n", group1_name, n_g1, group2_name, n_g2))
target_n <- min(n_g1, n_g2)
set.seed(123)
data_g1_balanced <- data_g1 %>% sample_n(target_n)
data_g2_balanced <- data_g2 %>% sample_n(target_n)
balanced_df <- bind_rows(data_g1_balanced, data_g2_balanced)
cat(sprintf("平衡後數量 -> 各 %d 筆 (總共 %d 筆)\n", target_n, nrow(balanced_df)))
return(balanced_df)
}
us_data_for_tree <- final_data_for_tree%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
bad_group_balanced <- do_undersampling(
us_data_for_tree,
"Hot_with_Safe_Neighbors_highbetweenness",
"Broken_Neighbors"
)
res_group_balanced <- do_undersampling(
us_data_for_tree,
"Cold_with_Hot_Neighbors_highbetweenness",
"Resilient_Neighbors"
)
bad_group_balanced <- do_undersampling(
us_data_for_tree,
"Broken",# Hot_with_Safe_Neighbors_highbetweenness
"Broken_Neighbors"
)
res_group_balanced <- do_undersampling(
us_data_for_tree,
"Resilient", # Cold_with_Hot_Neighbors_highbetweenness
"Resilient_Neighbors"
)
us_data_for_tree <- final_data_for_tree%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
bad_group_balanced <- do_undersampling(
us_data_for_tree,
"Broken",# Hot_with_Safe_Neighbors_highbetweenness
"Broken_Neighbors"
)
res_group_balanced <- do_undersampling(
us_data_for_tree,
"Resilient", # Cold_with_Hot_Neighbors_highbetweenness
"Resilient_Neighbors"
)
#| message: false
#| warning: false
tree_bad_model <- rpart(Group_Label ~ . ,
data = bad_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = bad_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(bad_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_bad_model.png", width = 1200, height = 800)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
tree_res_model <- rpart(Group_Label ~ . ,
data = res_group_balanced,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_res_model, newdata = res_group_balanced, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(res_group_balanced$Group_Label))
print(conf_matrix)
png("../Layouts/tree_res_model.png", width = 1200, height = 900, res = 300)
rpart.plot(tree_res_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1.1,
# varlen = 0,
# faclen = 0,
)
dev.off()
gc()
