all_features_grid <- cbind(all_features, grid_filter)
node_hotspot_values <- vapply(Mapper$points_in_vertex, function(idx) {
mean(all_features$hotspot[idx], na.rm = TRUE)
}, numeric(1))
features$hotspot <- node_hotspot_values
features <- features%>%mutate(hotspott = ifelse(hotspot > 0.2, 1, 0))
filter_features <- features%>%
mutate(
neighbor_points = map(neighbors, function(nbr_ids) {
# get all points in neighbor vertices
points_list <- points_in_vertex[nbr_ids]
all_nbr_points <- unlist(points_list)
unique(all_nbr_points)
}),
# count of neighbor points
neighbor_point_size = sapply(neighbor_points, length),
# count of neighbor nodes
neighbor_node_size = sapply(adj_list, length)
)%>%
filter(!map_lgl(neighbor_points, is.null))
hotspot_threshold <- 0.5
df <- features %>% mutate(is_hotspot = hotspot > hotspot_threshold)
df <- df %>%
# check if there's hot or safe neighbor first
mutate(
neighbor_hotspot_ratio = map_dbl(neighbors, function(idx) {
if(length(idx) == 0) return(0)
mean(df$is_hotspot[idx])}),
has_safe_neighbor = neighbor_hotspot_ratio < 1,
has_hot_neighbor = neighbor_hotspot_ratio > 0)%>%
# check if itself is hot or safe & the neighbor_hotspot_ratio
# set high betweenness threshold
mutate(
node_category = case_when(
is_hotspot == TRUE & has_safe_neighbor == TRUE ~ "Hot_with_Safe_Neighbors",
is_hotspot == FALSE & has_hot_neighbor == TRUE ~ "Cold_with_Hot_Neighbors",
TRUE ~ "Others"
),
is_high_betweenness = betweenness >= quantile(df$betweenness, 0.9)
)%>%
# finally find the interesting point
mutate(
final_category = case_when(
is_hotspot == TRUE & has_safe_neighbor == TRUE & is_high_betweenness == TRUE ~ "Hot_with_Safe_Neighbors_highbetweenness",
is_hotspot == FALSE & has_hot_neighbor == TRUE & is_high_betweenness == TRUE ~ "Cold_with_Hot_Neighbors_highbetweenness",
TRUE ~ "Others"
)
)
table(df$final_category)
# library(sf)
# roads <- st_read(dsn="../CalculatedData/pairs_annot_all_cities.shp")
# # grid_filter <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_filter.csv")
# grid_gi <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_giV1.csv")%>%
#   filter(num_accidents>0)%>%
#   mutate(index = row_number())
#
# grid_sf <- st_as_sf(grid_gi, wkt = "geometry", crs = 3826)
# roads <- st_transform(roads, 3826)
# joined_data <- st_join(grid_sf, roads, join = st_intersects, left = TRUE)
#
# result <- joined_data %>%
#   group_by(index) %>%
#   summarise(
#     max_spd_dlt = max(spd_dlt, na.rm = TRUE),
#     road_count = n(),
#     num_accidents = first(num_accidents),
#     .groups = "drop"
#   ) %>%
#   mutate(max_spd_dlt = ifelse(is.infinite(max_spd_dlt), 0, max_spd_dlt))
source('../utils/model.R')
final_all_features <- cbind(all_features)#, result$max_spd_dlt)
result_data <- get_comparison_data(df, final_all_features)
result_data%>%
group_by(group_label)%>%
summarize(n())
final_data_for_tree <- get_four_categories_data(df, final_all_features)
final_data_for_tree <- final_data_for_tree %>%
mutate(Group_Label = recode(Group_Label,
"Hot_with_Safe_Neighbors_highbetweenness" = "Broken",
"Cold_with_Hot_Neighbors_highbetweenness" = "Resilient"
))
table(final_data_for_tree$Group_Label)
all_features_mean <- final_data_for_tree %>%
group_by(Group_Label) %>%
summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE))) %>%
ungroup()
all_features_mean$Group_Label%>%unique()
comparison_table <- all_features_mean %>%
pivot_longer(
cols = -Group_Label,
names_to = "Feature",
values_to = "Mean_Value"
) %>%
pivot_wider(
names_from = Group_Label,
values_from = "Mean_Value"
)
for (main_group in c("Broken", "Resilient")) {
neighbor_group <- paste0(main_group, "_Neighbors")
overlap_group  <- paste0(main_group, "_Overlap")
group_order <- c(main_group, overlap_group, neighbor_group)
plot_data <- comparison_table %>%
filter(!Feature %in% l, Feature != 'Road Edge Line_Present') %>%
mutate(diff_val = abs(.data[[main_group]] - .data[[neighbor_group]])) %>%
arrange(desc(diff_val)) %>%
head(20) %>%
mutate(Feature = reorder(Feature, diff_val)) %>%
pivot_longer(
cols = -c(Feature, diff_val),
names_to = "Group",
values_to = "Value")%>%
filter(Group %in% group_order) %>%
mutate(Group = factor(Group, levels = group_order))
p <- ggplot(plot_data, aes(x = reorder(Feature, Value), y = Value, fill = Group)) +
geom_col(position = "dodge", width = 0.7) +
coord_flip() +
labs(title = paste(main_group, "Group"), y = "Mean Proportion", x = NULL) +
theme_minimal()
print(p)
}
do_undersampling <- function(
df, group1_name, group2_name
) {
data_g1 <- df %>% filter(Group_Label == group1_name)
data_g2 <- df %>% filter(Group_Label == group2_name)
n_g1 <- nrow(data_g1)
n_g2 <- nrow(data_g2)
cat(sprintf("原始數量 -> %s: %d, %s: %d\n", group1_name, n_g1, group2_name, n_g2))
target_n <- min(n_g1, n_g2)
set.seed(123)
data_g1_balanced <- data_g1 %>% sample_n(target_n)
data_g2_balanced <- data_g2 %>% sample_n(target_n)
balanced_df <- bind_rows(data_g1_balanced, data_g2_balanced)
cat(sprintf("平衡後數量 -> 各 %d 筆 (總共 %d 筆)\n", target_n, nrow(balanced_df)))
return(balanced_df)
}
# us_data_for_tree <- final_data_for_tree%>%select(-hotspot, -cols_to_remove, -no_lane, -bn_feature, -lr_feature)
library(scales)
us_data_for_tree <- final_data_for_tree %>%
select(-matches("County|ent"))
target_cols <- c("hotspot", "Group_Label")
us_data_for_tree <- us_data_for_tree %>%
mutate(across(
.cols = where(is.numeric) & !all_of(target_cols),
.fns = ~ scales::rescale(.)
))
us_data_for_tree$Group_Label%>%unique()
exclude_cols <- c("hotspot", "group_label", "grid_id", "bn_feature", "lr_feature", "no_lane")
us_data_cleaned <- us_data_for_tree %>%
filter(Group_Label %in% c("Broken_Neighbors", "Resilient_Neighbors", "Broken", "Resilient")) %>%
ungroup() %>%
mutate(Group_Label = case_when(
Group_Label == "Broken_Neighbors" ~ "Resilient",
Group_Label == "Resilient_Neighbors" ~ "Broken",
TRUE ~ Group_Label
))%>%
distinct()
categorize_feature <- function(x) {
case_when(
x >= 0.8 ~ "Dominant",
x <= 0.2 ~ "Minor",
TRUE ~ "Mixed"
)
}
us_data_cleaned <- us_data_cleaned %>%
mutate(across(
.cols = where(is.numeric) & !any_of(exclude_cols),
.fns = function(x) {
if (max(x, na.rm = TRUE) <= 1 && min(x, na.rm = TRUE) >= 0) {
return(categorize_feature(x))
} else {
return(x)
}
}
)) %>%
mutate(across(where(is.character), as.factor))%>%
select(-c('lr_feature', 'hotspot', 'bn_feature', 'no_lane'))
us_data_cleaned$Group_Label%>%table()
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01, minbucket = 30),
parms = list(prior = c(0.5, 0.5))
)
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 10,
control = rpart.control(cp = 0.01, minbucket = 30),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = us_data_cleaned, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(us_data_cleaned$Group_Label))
print(conf_matrix)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1,
# varlen = 0,
# faclen = 0,
)
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 10,
control = rpart.control(cp = 0.005, minbucket = 30),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = us_data_cleaned, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(us_data_cleaned$Group_Label))
print(conf_matrix)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1,
# varlen = 0,
# faclen = 0,
)
us_data_cleaned
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 10,
control = rpart.control(cp = 0.005, minbucket = 50),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = us_data_cleaned, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(us_data_cleaned$Group_Label))
print(conf_matrix)
us_data_cleaned$Group_Label%>%table()
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 10,
control = rpart.control(cp = 0.01, minbucket = 50),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = us_data_cleaned, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(us_data_cleaned$Group_Label))
print(conf_matrix)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1,
# varlen = 0,
# faclen = 0,
)
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.005, minbucket = 50),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = us_data_cleaned, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(us_data_cleaned$Group_Label))
print(conf_matrix)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1,
# varlen = 0,
# faclen = 0,
)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1,
# varlen = 0,
# faclen = 0,
)
tree_bad_model <- rpart(Group_Label ~ . ,
data = us_data_cleaned,
method = "class",
maxdepth = 5,
control = rpart.control(cp = 0.01, minbucket = 50),
parms = list(prior = c(0.5, 0.5))
)
pred_class <- predict(tree_bad_model, newdata = us_data_cleaned, type = "class")
conf_matrix <- confusionMatrix(data = pred_class, reference = as.factor(us_data_cleaned$Group_Label))
print(conf_matrix)
# rpart.plot(tree_bad_model, family = "PingFang", tweak = 1.5)
rpart.plot(tree_bad_model,
type = 4,
extra = 106,
under = TRUE,
fallen.leaves = FALSE,
box.palette = "BuGn",
# shadow.col = "gray",
nn = TRUE,
tweak = 1,
# varlen = 0,
# faclen = 0,
)
tree_bad_model
library(sf)
library(tidyverse)
boundary <- st_read('../ST-RTA/ComputedDataV2/Taiwan/taiwan.shp')
youbike <- read_csv('../ST-RTA/ComputedData/Youbike/full_youbike.csv')%>%
st_as_sf(coords = c("PositionLon", "PositionLat"), crs = 4326)%>%
st_transform(3826)
roads <- st_read("./Data/road_new.shp/gis_osm_roads_free_1.shp")
library(sf)
library(tidyverse)
# 這個檔案的目的是找出離每個事故最近的youbike設施
youbike <- read_csv('../ST-RTA/ComputedData/Youbike/full_youbike.csv')
mrt <- read_csv('../ST-RTA/ComputedData/MRT/full_mrt.csv')
parking <- read_csv('../ST-RTA/ComputedData/Parkinglot/full_parkinglot.csv')
combined_data1 <- read_csv("~/Desktop/ST-RTA/ComputedDataV2/Accident/combined_data_in_taiwan.csv")
combined_data <- combined_data1%>%filter(`道路類別-第1當事者-名稱` == '市區道路')
youbike_sf <- st_as_sf(youbike, coords = c("PositionLon", "PositionLat"), crs = 4326) %>%
st_transform(3826)
mrt_sf <- st_as_sf(mrt, coords = c("PositionLon", "PositionLat"), crs = 4326) %>%
st_transform(3826)
parking_sf <- st_as_sf(parking, coords = c("PositionLon", "PositionLat"), crs = 4326) %>%
st_transform(3826)
combined_sf <- st_as_sf(combined_data, coords = c("經度", "緯度"), crs = 4326) %>%
st_transform(3826)
nearest_idx <- st_nearest_feature(combined_sf, youbike_sf)
dist_to_youbike <- st_distance(combined_sf, youbike_sf[nearest_idx,], by_element = TRUE)
combined_data$dist_to_nearest_youbike <- as.numeric(dist_to_youbike)
threshold <- quantile(combined_data$dist_to_nearest_youbike, 0.90, na.rm = TRUE)
med <- median(combined_data$dist_to_nearest_youbike, na.rm = TRUE)
mean_dist <- mean(combined_data$dist_to_nearest_youbike, na.rm = TRUE)
# plot distribution
distance_youbike <- combined_data%>%
filter(dist_to_nearest_youbike <= threshold) %>%
ggplot(aes(x = dist_to_nearest_youbike)) +
geom_histogram(binwidth = 10) +
# medianline
geom_vline(xintercept = med, color = "blue", linetype = "dashed", size = 1) +
geom_vline(xintercept = mean_dist, color = "red", linetype = "dashed", size = 1) +
annotate("text", x = med, y = Inf, label = paste("Median:", round(med, 2)),
color = "blue", vjust = 1.5, hjust = 1.1, size = 3.5) +
annotate("text", x = mean_dist, y = Inf, label = paste("Median:", round(mean_dist, 2)),
color = "red", vjust = 1.5, hjust = 1.1, size = 3.5) +
labs(title = "Distribution of Distance to Nearest Youbike Station",
x = "Distance to Nearest Youbike Station (meters)",
y = "Frequency") +
theme_minimal()
# Simulation
# https://rpubs.com/Peters64s/548577
library(future.apply)
plan(multisession, workers = 3)
message(paste("Cell:", availableCores() - 1))
facility_list <- list(
"Youbike" = youbike_sf,
"MRT" = mrt_sf,
"Parking" = parking_sf
)
for (f_name in names(facility_list)){
dt <- facility_list[[f_name]]
n_sample_size <- 10000
n_sim <- 50
dist_grid <- seq(0, 500, by = 5)
urban_mask <- youbike_sf %>%
st_buffer(500) %>%
st_union() %>%
st_as_sf()
set.seed(123)
idx_obs <- st_nearest_feature(combined_sf, dt)
real_dists_actual <- as.numeric(st_distance(combined_sf, dt[idx_obs,], by_element = TRUE))
real_cdf <- ecdf(real_dists_actual)(dist_grid)
run_simulation <- function(i) {
rand_pts <- st_sample(urban_mask, size = n_sample_size) %>%
st_as_sf() %>%
st_cast("POINT")
idx <- st_nearest_feature(rand_pts, dt)
dists <- st_distance(rand_pts, dt[idx,], by_element = TRUE)
dists_numeric <- as.numeric(dists)
return(ecdf(dists_numeric)(dist_grid))
}
results_list <- future_lapply(1:n_sim, run_simulation, future.seed = 999)
# col: times of simulation, row: distance grid
sim_results_matrix <- do.call(cbind, results_list)
plan(sequential)
env_hi <- apply(sim_results_matrix, 1, max)
env_lo <- apply(sim_results_matrix, 1, min)
env_mean <- apply(sim_results_matrix, 1, mean)
plot_data <- data.frame(
distance = dist_grid,
obs = real_cdf,
hi = env_hi,
lo = env_lo,
mean = env_mean
)
simulation <- ggplot(plot_data, aes(x = distance)) +
geom_ribbon(aes(ymin = lo, ymax = hi), fill = "grey70", alpha = 0.5) +
geom_line(aes(y = mean, color = "Random Baseline (CSR)"), linetype = "dashed", linewidth = 1) +
geom_line(aes(y = obs, color = "Real Accidents"), linewidth = 1.2) +
scale_color_manual(values = c("Real Accidents" = "black", "Random Baseline (CSR)" = "red")) +
labs(title = paste("Spatial Association Test:", f_name),
subtitle = paste0("Observed vs. ", n_sim, " Simulations"),
x = paste("Distance to Nearest", f_name, "(meters)"),
y = "Cumulative Proportion (CDF)",
color = "Legend") +
theme_minimal() +
theme(legend.position = "bottom")
file_name <- paste0("./Layouts/simulation_", f_name, ".png")
ggsave(file_name, simulation, width = 6, height = 6)
message(paste("Completed simulation for", f_name))
}
# 串連速限以及youbike之間的關聯
med <- median(combined_data$`速限-第1當事者`, na.rm = TRUE)
mean_dist <- mean(combined_data$`速限-第1當事者`, na.rm = TRUE)
speed_distribution <- combined_data%>%
ggplot() +
geom_histogram(aes(x = `速限-第1當事者`), binwidth = 10, fill = "lightblue", color = "black") +
geom_vline(xintercept = med, color = "blue", linetype = "dashed", size = 1) +
geom_vline(xintercept = mean_dist, color = "red", linetype = "dashed", size = 1) +
annotate("text", x = med, y = Inf, label = paste("Median:", round(med, 2)),
color = "blue", vjust = 1.5, hjust = -0.1, size = 3.5) +
annotate("text", x = mean_dist, y = Inf, label = paste("Mean:", round(mean_dist, 2)),
color = "red", vjust = 1.5, hjust = 1.1, size = 3.5) +
labs(title = "Distribution of Speed Limits for Urban Road Accidents",
x = "Speed Limit (km/h)",
y = "Frequency") +
theme_minimal()
# Speed difference
# boundary <- st_read('../ST-RTA/ComputedDataV2/Taiwan/taiwan.shp')
boundary <- read_csv('../ST-RTA/ComputedDataV2/Taiwan/taiwan_無離島.csv')%>%
st_as_sf(wkt = "geometry", crs = 3826)
differnce <- st_read("./CalculatedData/pairs_annot_all_cities.shp")%>%
st_as_sf(geometry = "geometry", crs = 3826)%>%
# find the points in boundary
st_join(boundary, join = st_within, left = FALSE)
## speed 不討論速差，只考慮距離到速差點
nearest_idx <- st_nearest_feature(combined_sf, differnce)
dist_to_spd <- st_distance(combined_sf, differnce[nearest_idx,], by_element = TRUE)
combined_data$dist_to_nearest_spd <- as.numeric(dist_to_spd)
n_sample_size <- 10000
n_sim <- 50
n_points <- nrow(combined_data)
dist_grid <- seq(0, 300, by = 5)
urban_mask <- differnce %>%
st_buffer(300) %>%
st_union() %>%
st_as_sf()
set.seed(123)
accidents_sampled <- combined_data %>% sample_n(n_sample_size)
real_dists <- accidents_sampled$dist_to_nearest_spd
real_cdf <- ecdf(real_dists)(dist_grid)
run_simulation <- function(i) {
rand_pts <- st_sample(urban_mask, size = n_sample_size) %>%
st_as_sf() %>%
st_cast("POINT")
idx <- st_nearest_feature(rand_pts, differnce)
dists <- st_distance(rand_pts, differnce[idx,], by_element = TRUE)
dists_numeric <- as.numeric(dists)
return(ecdf(dists_numeric)(dist_grid))
}
results_list <- future_lapply(1:n_sim, run_simulation, future.seed = 999)
# col: times of simulation, row: distance grid
sim_results_matrix <- do.call(cbind, results_list)
plan(sequential)
env_hi <- apply(sim_results_matrix, 1, max)
env_lo <- apply(sim_results_matrix, 1, min)
env_mean <- apply(sim_results_matrix, 1, mean)
real_dists <- combined_data$dist_to_nearest_spd
real_cdf <- ecdf(real_dists)(dist_grid)
plot_data <- data.frame(
distance = dist_grid,
obs = real_cdf,
hi = env_hi,
lo = env_lo,
mean = env_mean
)
simulation <- ggplot(plot_data, aes(x = distance)) +
geom_ribbon(aes(ymin = lo, ymax = hi), fill = "grey70", alpha = 0.5) +
geom_line(aes(y = mean, color = "Random Baseline (CSR)"), linetype = "dashed", linewidth = 1) +
geom_line(aes(y = obs, color = "Real Accidents"), linewidth = 1.2) +
scale_color_manual(values = c("Real Accidents" = "black", "Random Baseline (CSR)" = "red")) +
labs(title = "Spatial Association Test",
subtitle = paste0("Observed vs. ", n_sim, " Simulations"),
x = "Distance to Nearest Speed Difference (meters)",
y = "Cumulative Proportion (CDF)",
color = "Legend") +
theme_minimal() +
theme(legend.position = "bottom")
simulation
combined_data
