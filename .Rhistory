grid_filter <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_filter.csv")$accident_indices
grid_filter <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_filter.csv")$accident_indices
grid_filter <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_filter.csv")$accident_indices
combined_data <- read_csv("../../ST-RTA/ComputedDataV2/Grid/combined_data.csv")
MapperCorrelation(Mapper, original_data = filter_data, labels = list(all_features$bn_feature, all_features$hotspot), use_embedding = list(FALSE, FALSE))
length(g)
length(e_scores)
features <- tibble(
size = node_sizes <- sapply(Mapper$points_in_vertex, length),
eigen_centrality = e_scores,
betweenness = b_scores,
neighbors = adj_list, # neighbor vertex indices
points_in_vertex = Mapper$points_in_vertex # original data indices in each vertex
)
all_features_grid <- cbind(all_features, grid_filter)
node_hotspot_values <- vapply(Mapper$points_in_vertex, function(idx) {
mean(all_features$hotspot[idx], na.rm = TRUE)
}, numeric(1))
features$hotspot <- node_hotspot_values
features <- features%>%
mutate(hotspott = ifelse(hotspot > 0.2, 1, 0))
filter_features <- features%>%
mutate(
neighbor_points = map(neighbors, function(nbr_ids) {
# get all points in neighbor vertices
points_list <- points_in_vertex[nbr_ids]
all_nbr_points <- unlist(points_list)
unique(all_nbr_points)
}),
# count of neighbor points
neighbor_point_size = sapply(neighbor_points, length),
# count of neighbor nodes
neighbor_node_size = sapply(adj_list, length)
)%>%
filter(!map_lgl(neighbor_points, is.null))
library(jsonlite)
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = as.data.frame(all_features),
# this is the label that already calculated for each node
cc = tibble(
eigen_centrality = e_scores,
betweenness = b_scores,
weighted_betweenness = b_scores_weighted,
weighted_eigen_centrality = e_scores_weighted,
eigen_top10 = e_labels,
betweenness_top10 = b_labels,
threshold_hotspot = features$hotspott
)
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/my_mapper_graph.json")
library(GGally)
ggpairs(filter_features,
columns = c("size", "eigen_centrality", "betweenness",
"neighbor_point_size", "neighbor_node_size", "hotspot"),
upper = list(continuous = wrap("cor", method = "spearman")))
#| message: false
#| warning: false
library(GGally)
ggpairs(filter_features,
columns = c("size", "eigen_centrality", "betweenness",
"neighbor_point_size", "neighbor_node_size", "hotspot"),
upper = list(continuous = wrap("cor", method = "spearman")))
cols_to_remove <- c(
"車道劃分設施-分道設施-快車道或一般車道間名稱_車道線(無標記)",
"車道劃分設施-分道設施-快車道或一般車道間名稱_車道線(附標記)",
"車道劃分設施-分道設施-快車道或一般車道間名稱_禁止變換車道線(無標記)",
"車道劃分設施-分道設施-快車道或一般車道間名稱_禁止變換車道線(附標記)",
"車道劃分設施-分道設施-快慢車道間名稱_寬式快慢車道分隔島(50公分以上)",
"車道劃分設施-分道設施-快慢車道間名稱_快慢車道分隔線",
"車道劃分設施-分道設施-快慢車道間名稱_窄式快慢車道分隔島(無柵欄)",
"車道劃分設施-分道設施-快慢車道間名稱_窄式快慢車道分隔島(附柵欄)",
"車道劃分設施-分道設施-路面邊線名稱_有",
"車道劃分設施-分向設施大類別名稱_行車分向線",
"車道劃分設施-分向設施大類別名稱_雙向禁止超車線",
"車道劃分設施-分向設施大類別名稱_單向禁止超車線",
"車道劃分設施-分向設施大類別名稱_中央分向島"
)
bdt <- get_model_grid(filter_features, betweenness, top_k = 10)
edt <- get_model_grid(filter_features, eigen_centrality, top_k = 10)
top_betweenness <- bdt[[1]]
top_eigen <- edt[[1]]
common_nodes <- inner_join(top_betweenness, top_eigen)
betweenness_only <- anti_join(top_betweenness, top_eigen)
eigen_only <- anti_join(top_eigen, top_betweenness)
dim(betweenness_only)[1] + dim(common_nodes)[1] == dim(top_betweenness)[1] &
dim(eigen_only)[1] + dim(common_nodes)[1] == dim(top_eigen)[1]
source('../utils/model.R')
###########
top_betweenness$type <- 1
top_eigen$type <- 0
n_between <- nrow(betweenness_only)
n_eigen <- nrow(eigen_only)
target_size <- min(n_between, n_eigen)
fdt <- bind_rows(
top_betweenness %>% sample_n(target_size),
top_eigen %>% sample_n(target_size)
)%>%select(-bn_feature, -grid_filter, -hotspot, -all_of(cols_to_remove))
result <- glm_report(fdt)
result$importance_df%>%
filter(Importance > 1.96)%>%
ggplot(aes(x = Importance, y = Variable, color = Direction)) +
geom_segment(aes(x = 0, xend = Importance, y = Variable, yend = Variable), linewidth = 1) +
geom_point(size = 4) +
scale_color_manual(values = c("Betweenness" = "#E41A1C", "Eigen" = "#377EB8")) +
theme_minimal(base_family = "PingFang TC")+
labs(x="Variable Importance", y="Variables")
# odds ratio
result$importance_df%>%
filter(Importance > 1.96)%>%
ggplot(aes(x = OddsRatio, y = Variable, color = Direction)) +
geom_segment(aes(x = 1, xend = OddsRatio, y = Variable, yend = Variable), linewidth = 1) +
geom_point(size = 4) +
scale_color_manual(values = c("Betweenness" = "#E41A1C", "Eigen" = "#377EB8")) +
theme_minimal(base_family = "PingFang TC")+
labs(x="Odds Ratio", y="Variables")
getwd()
source('../utils/model.R')
source('../../TDA-R/MapperAlgo/R/Plotter.R')
source('../../TDA-R/MapperAlgo/R/MapperCorrelation.R')
grid_filter <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_filter.csv")$accident_indices
library(tidyverse)
library(igraph)
library(networkD3)
library(ggraph)
library(tidygraph)
library(parallel)
library(doParallel)
source('../../TDA-R/MapperAlgo/R/EdgeVertices.R')
source('../../TDA-R/MapperAlgo/R/ConvertLevelsets.R')
source('../../TDA-R/MapperAlgo/R/Cover.R')
source('../../TDA-R/MapperAlgo/R/Cluster.R')
source('../../TDA-R/MapperAlgo/R/SimplicialComplex.R')
source('../../TDA-R/MapperAlgo/R/MapperAlgo.R')
source('../../TDA-R/MapperAlgo/R/Plotter.R')
filter_data <- read_csv("../../ST-RTA/ComputedDataV4/ForModel/filtered_dataV1.csv")
filter_data%>%summary()
# all_features <- read_csv("../ST-RTA/ComputedDataV4/ForModel/all_features_gdf.csv")
all_features <- read_csv("../../ST-RTA/ComputedDataV4/ForModel/all_features.csv")
all_features$hotspot <- case_when(
all_features$hotspot == 'Not Significant' ~ 0,
TRUE ~ 1)
all_features <- all_features%>%
mutate(
bn_feature = ifelse(
(
(
(`車道劃分設施-分道設施-路面邊線名稱_無` > 0)
) &
(
(`當事者區分-類別-大類別名稱-車種_小客車(含客、貨兩用)` > 0)
) &
(
(`cause-group_Decision` > 0)
)
),
1,
0
)
)
all_features <- all_features%>%
mutate(
no_lane = ifelse(
(
(
(`車道劃分設施-分道設施-路面邊線名稱_無` > 0)
) &
(
(`車道劃分設施-分向設施大類別名稱_無` > 0)
) &
(
(`車道劃分設施-分道設施-快車道或一般車道間名稱_未繪設車道線` > 0)
) &
(
(`車道劃分設施-分道設施-快慢車道間名稱_未繪設快慢車道分隔線` > 0)
) &
(
(`號誌-號誌種類名稱_無號誌` > 0)
)
),
1,
0
)
)
all_features <- all_features%>%
mutate(
no_lane = ifelse(
(
(
(`車道劃分設施-分道設施-路面邊線名稱_無` > 0)
) &
(
(`車道劃分設施-分向設施大類別名稱_無` > 0)
) &
(
(`車道劃分設施-分道設施-快車道或一般車道間名稱_未繪設車道線` > 0)
) &
(
(`車道劃分設施-分道設施-快慢車道間名稱_未繪設快慢車道分隔線` > 0)
) &
(
(`號誌-號誌種類名稱_無號誌` > 0)
)
),
1,
0
)
)
all_features <- all_features%>%
mutate(
lr_feature = ifelse(
(
(
(`事故類型及型態大類別名稱_車與車` > 0)
) &
(
(`當事者區分-類別-大類別名稱-車種_人` > 0)
) &
(
(`cause-group_Unidentified` > 0)
)
),
1,
0
)
)
all_features$bn_feature%>%table()
# normalize
n_data <- as.data.frame(scale(filter_data))
n_data%>%summary()
plot_data <- n_data %>%
mutate(is_hotspot = factor(all_features$hotspot)) %>%
pivot_longer(cols = -is_hotspot, names_to = "variable", values_to = "value")
plot_data %>%
ggplot(aes(x = value, fill = is_hotspot)) +
geom_histogram(bins = 50, color = "white", alpha = 0.8, position = "stack") +
facet_wrap(~variable, scales = "free") +
# Manual color scale with English labels
scale_fill_manual(values = c("0" = "#999999", "1" = "#E63946"),
name = "Hotspot Status",  labels = c("No", "Yes")) +
theme_minimal() +
labs(title = "Distribution of Variables by Hotspot Status",
subtitle = "Red indicates hotspot occurrences within the value range",
x = "Normalized Value",
y = "Frequency") +
theme(legend.position = "top")
data <- all_features%>%select(-hotspot)
time_taken <- system.time({
Mapper <- MapperAlgo(
original_data = data,
filter_values = n_data[,1:3],
percent_overlap = 0.5,
# methods = "dbscan",
# method_params = list(eps = 0.3, minPts = 3),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 5, method = 'ward.D2'),
methods = "kmeans",
method_params = list(max_kmeans_clusters = 3),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 0.7,
num_cores = 12
)
})
getwd()
source('../utils/model.R')
source('../../TDA-R/MapperAlgo/R/Plotter.R')
source('../../TDA-R/MapperAlgo/R/MapperCorrelation.R')
grid_filter <- read_csv("../../ST-RTA/ComputedDataV2/Grid/grid_filter.csv")$accident_indices
combined_data <- read_csv("../../ST-RTA/ComputedDataV2/Grid/combined_data.csv")
adj_matrix <- Mapper$adjacency
adj_list <- lapply(1:Mapper$num_vertices, function(i) {
neighbors <- which(adj_matrix[i, ] > 0)
return(neighbors[neighbors != i]) # 移除自己
})
# find total unique indices
uniq_idx <- sort(unique(unlist(Mapper$points_in_vertex, use.names = FALSE)))
length(uniq_idx) == dim(all_features)[1]
## Betweenness and Eigenvector Centrality
g <- graph_from_adjacency_matrix(Mapper$adjacency, mode = "undirected")
e_result <- eigen_centrality(g)
e_scores <- e_result$vector
b_scores <- betweenness(g, weights = NA, normalized = TRUE)
# 找橋樑
top_nodes <- sort(b_scores, decreasing = TRUE)
b_labels <- rep(0, length(b_scores))
top_10_indices <- head(order(b_scores, decreasing = TRUE), 10)
b_labels[top_10_indices] <- 1
e_labels <- rep(0, length(e_scores))
top_10_eigen_indices <- head(order(e_scores, decreasing = TRUE), 10)
e_labels[top_10_eigen_indices] <- 1
node_sizes <- pmax(sapply(Mapper$points_in_vertex, length), 1)
g <- graph_from_adjacency_matrix(Mapper$adjacency, mode = "undirected")
calc_edge_weight <- function(u, v) {
size_u <- node_sizes[u]
size_v <- node_sizes[v]
# the weight is inversely proportional to the sum of node sizes
# because larger nodes should have less influence on betweenness
return(1 / (size_u + size_v))
}
edge_list <- as_edgelist(g, names = FALSE)
edge_weights <- apply(edge_list, 1, function(x) calc_edge_weight(x[1], x[2]))
b_scores_weighted <- betweenness(g, weights = edge_weights, normalized = TRUE)
MapperPlotter(
Mapper,
label = b_scores_weighted,
original_data = filter_data,
use_embedding=TRUE
)
calc_eigen_weight <- function(u, v) {
size_u <- node_sizes[u]
size_v <- node_sizes[v]
return(size_u + size_v)
}
eigen_weights <- apply(edge_list, 1, function(x) calc_eigen_weight(x[1], x[2]))
e_result_weighted <- eigen_centrality(g, weights = eigen_weights)
e_scores_weighted <- e_result_weighted$vector
node_sizes <- pmax(sapply(Mapper$points_in_vertex, length), 1)
g <- graph_from_adjacency_matrix(Mapper$adjacency, mode = "undirected")
calc_edge_weight <- function(u, v) {
size_u <- node_sizes[u]
size_v <- node_sizes[v]
# the weight is inversely proportional to the sum of node sizes
# because larger nodes should have less influence on betweenness
return(1 / (size_u + size_v))
}
edge_list <- as_edgelist(g, names = FALSE)
edge_weights <- apply(edge_list, 1, function(x) calc_edge_weight(x[1], x[2]))
b_scores_weighted <- betweenness(g, weights = edge_weights, normalized = TRUE)
MapperPlotter(
Mapper,
label = b_scores_weighted,
original_data = filter_data,
use_embedding=TRUE
)
calc_eigen_weight <- function(u, v) {
size_u <- node_sizes[u]
size_v <- node_sizes[v]
return(size_u + size_v)
}
eigen_weights <- apply(edge_list, 1, function(x) calc_eigen_weight(x[1], x[2]))
e_result_weighted <- eigen_centrality(g, weights = eigen_weights)
e_scores_weighted <- e_result_weighted$vector
MapperPlotter(
Mapper,
# label = e_scores,
label = b_scores,
original_data = filter_data,
use_embedding=TRUE
)
MapperPlotter(
Mapper,
label = all_features$hotspot,
# label = all_features$lr_feature,
original_data = filter_data,
avg=TRUE,
use_embedding=FALSE
)
library(tidyverse)
# read json file
data <- jsonlite::fromJSON("~/desktop/my_mapper_graph.json")
data
data$num_vertices
# read json file
Mapper <- jsonlite::fromJSON("~/desktop/my_mapper_graph.json")
Mapper$cc$betweenness
# read json file
Mapper <- jsonlite::fromJSON("~/desktop/my_mapper_graph.json")
filter_data <- read_csv("../../ST-RTA/ComputedDataV4/ForModel/filtered_dataV1.csv")
MapperPlotter(
Mapper,
label = Mapper$cc$betweenness,
original_data = filter_data,
use_embedding=TRUE
)
Mapper$cc
cc <- Mapper$cc
cc$betweenness
cc
features$hotspot <- node_hotspot_values
features$hotspot
library(jsonlite)
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = as.data.frame(all_features),
# this is the label that already calculated for each node
cc = tibble(
eigen_centrality = e_scores,
betweenness = b_scores,
weighted_betweenness = b_scores_weighted,
weighted_eigen_centrality = e_scores_weighted,
eigen_top10 = e_labels,
betweenness_top10 = b_labels,
threshold_hotspot = features$hotspot
)
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/my_mapper_graph.json")
# read json file
Mapper <- jsonlite::fromJSON("~/desktop/my_mapper_graph.json")
cc <- Mapper$cc
cc
geom_point(aes(x = betweenness, y = threshold_hotspot)
cc%>%
cc%>%
ggplot()+
geom_point(aes(x = betweenness, y = threshold_hotspot)
, color = ifelse(b_labels == 1, "red", "black"))
cc%>%
ggplot()+
geom_point(aes(x = betweenness, y = threshold_hotspot,))
cc%>%
ggplot()+
geom_point(aes(x = betweenness, y = threshold_hotspot))
ggplot(cc)+
geom_point(aes(x = betweenness, y = threshold_hotspot))+
ggplot(cc%>%filter(betweenness>0.015, threshold_hotspot>0.35))+
geom_point(aes(x = betweenness, y = threshold_hotspot))
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.5) +
geom_point(data = cc %>% filter(betweenness > 0.015, threshold_hotspot > 0.35),
color = "red", size = 3)
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > 0.015, threshold_hotspot > 0.35),
color = "red", size = 3)
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > 0.015, threshold_hotspot > 0.35),
color = "red", size = 3)
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > 0.015, threshold_hotspot > 0.5),
color = "red", size = 3)
Q3_x <- quantile(cc$betweenness, 0.75, na.rm = TRUE)
IQR_x <- IQR(cc$betweenness, na.rm = TRUE)
upper_bound_x <- Q3_x + 1.5 * IQR_x
Q3_y <- quantile(cc$threshold_hotspot, 0.75, na.rm = TRUE)
IQR_y <- IQR(cc$threshold_hotspot, na.rm = TRUE)
upper_bound_y <- Q3_y + 1.5 * IQR_y
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.5) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x,
threshold_hotspot > upper_bound_y),
color = "red", size = 3) +
geom_vline(xintercept = upper_bound_x, linetype = "dashed") +
geom_hline(yintercept = upper_bound_y, linetype = "dashed")
Q3_x <- quantile(cc$betweenness, 0.75, na.rm = TRUE)
IQR_x <- IQR(cc$betweenness, na.rm = TRUE)
upper_bound_x <- Q3_x + 1 * IQR_x
Q3_y <- quantile(cc$threshold_hotspot, 0.75, na.rm = TRUE)
IQR_y <- IQR(cc$threshold_hotspot, na.rm = TRUE)
upper_bound_y <- Q3_y + 1* IQR_y
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.5) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x,
threshold_hotspot > upper_bound_y),
color = "red", size = 3) +
geom_vline(xintercept = upper_bound_x, linetype = "dashed") +
geom_hline(yintercept = upper_bound_y, linetype = "dashed")
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > 0.015, threshold_hotspot > 0.5),
color = "red", size = 3)
Q3_x <- quantile(cc$betweenness, 0.75, na.rm = TRUE)
IQR_x <- IQR(cc$betweenness, na.rm = TRUE)
upper_bound_x <- Q3_x + 1 * IQR_x
Q3_y <- quantile(cc$threshold_hotspot, 0.75, na.rm = TRUE)
IQR_y <- IQR(cc$threshold_hotspot, na.rm = TRUE)
upper_bound_y <- Q3_y + 1* IQR_y
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.5) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x,
threshold_hotspot > upper_bound_y),
color = "red", size = 3) +
geom_vline(xintercept = upper_bound_x, linetype = "dashed") +
geom_hline(yintercept = upper_bound_y, linetype = "dashed")
upper_bound_x <- Q3_x + 1.5 * IQR_x
Q3_y <- quantile(cc$threshold_hotspot, 0.75, na.rm = TRUE)
IQR_y <- IQR(cc$threshold_hotspot, na.rm = TRUE)
upper_bound_y <- Q3_y + 1* IQR_y
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.5) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x,
threshold_hotspot > upper_bound_y),
color = "red", size = 3) +
geom_vline(xintercept = upper_bound_x, linetype = "dashed") +
geom_hline(yintercept = upper_bound_y, linetype = "dashed")
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x, threshold_hotspot > 0.5),
color = "red", size = 3)
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x, threshold_hotspot > 0.5),
color = "red", size = 3) +
geom_vline(xintercept = upper_bound_x, linetype = "dashed")
cc %>% filter(betweenness > upper_bound_x, threshold_hotspot > 0.5)
hotspot_and_high_between <- cc%>%filter(betweenness > upper_bound_x, threshold_hotspot > 0.5)
hotspot_and_high_between
ggplot(cc, aes(x = betweenness, y = threshold_hotspot)) +
geom_point(color = "grey", alpha = 0.7) +
geom_point(data = cc %>% filter(betweenness > upper_bound_x, threshold_hotspot > 0.5),
color = "red", size = 3) +
geom_vline(xintercept = upper_bound_x, linetype = "dashed")
